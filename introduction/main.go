package main // определение пакета для текущего файла
import "fmt" // подключение пакета fmt

// Основы языка Go на примерах с комментариями.
/*
fmt это format. Этот пакет позволяет форматировать основные строки, значения или что-либо и печатать их, или собирать пользовательский ввод с консоли, или записывать в файл с помощью средства записи, или даже печатать настраиваемые причудливые сообщения об ошибках.
Этот пакет предназначен для форматирования ввода и вывода. */

// условные конструкции
// теория - Конструкция if принимает условие - выражение, которое возвращает значение типа bool. И если это условие истинно,
// то выполняется последующий блок инструкций.
func ConditionalStatements(a int, b int) {
	if a < b {
		fmt.Println("a меньше b")
	} else if a > b {
		fmt.Println("а больше b")
	} else if a == b {
		fmt.Println("а равно b")
	} else {
		fmt.Println("Сюда не зайдет")
	}
}

func EnumerationManyOptions(a int) {
	switch a + 2 {
	case 3:
		fmt.Println("a = 3")
	case 4:
		fmt.Println("a = 4")
	case 5, 6, 7:
		fmt.Println("a = 5")
	default:
		fmt.Println("значение переменной а неизвестно")
	}
}

// циклы
/* шаблон цикла
for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}
Объявление цикла for разбивается на три части. Вначале идет инициализация счетчика: i := 1. Фактически она представляет объявление переменной, которая будет использоваться внутри цикла. В данном случае это счетчик i, начальное значение которого равно 1.

Вторая часть представляет условие: i < 10. Пока это условие истинно, то есть возвращает true, будет продолжаться цикл.

Третья часть представляет изменение (увеличение) счетчика на единицу.
*/

func loopExample() {
	var count = 12
	for i := 0; i < count; i++ {
		fmt.Println(i * i)
	}
	// вложенный цикл
	for i := 1; i < 10; i++ {
		for j := 1; j < 10; j++ {
			fmt.Print(i*j, "\t")
		}
		fmt.Println()
	}
	/* варианты условий в цикле
		Нам необязательно указывать все условия при объявлении цикла. Например, можно вынести объявление переменной вовне:
		var i = 1
		for ; i < 10; i++{
	    	fmt.Println(i * i)
		}
		Можно убрать изменение счетчика в само тело цикла и оставить только условие:
		var i = 1
		for ; i < 10;{
	    	fmt.Println(i * i)
	    	i++
		}
		Если цикл использует только условие, то его можно сократить следующим образом:
		var i = 1
		for i < 10{
	    	fmt.Println(i * i)
	    	i++
	*/
}

// циклы

/* перебор массива
Для перебора массивов можно использовать следующую форму цикла for:
for индекс, значение := range массив{
    // действия
}
*/
func IteratingOverArrays() {
	var users = [3]string{"Alexandr", "Vladimir", "Roma"}
	for index, value := range users {
		fmt.Println(index, value)
	}
	/*
	   Если мы не планируем использовать значения или индексы элементов, то мы можем вместо них указать прочерк. Например, нам не нужны индексы:

	   for _, value := range users{
	       fmt.Println(value)
	   }

	   Но также для перебора массива можно использовать и стандартную версию цикла for:

	   var users = [3]string{"Tom", "Alice", "Kate"}
	   for i:= 0; i < len(users); i++{
	       fmt.Println(users[i])
	   }
	   В данном случае счетчик i играет роль индекса. Цикл выполняется, пока счетчик i не станет равным длине массива, которую можно получить с помощью функции len()
	*/
}

// перебор массива

// break continue
/*
Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла,
а сразу перейти к следующей итерации.
В этом случае можно использовать оператор continue. Например, в массиве могу быть, как положительные, так и отрицательные числа.
Допустим, нам нужна сумма только положительных чисел, поэтому, если нам встретится отрицательное число,
мы можем просто перейти к следующей итерации с помощью continue:
*/

func interruptionPossibilities() {
	var numbers = [10]int{1, -2, 3, -4, 5, -6, -7, 8, -9, 10}
	var sum = 0
	for _, value := range numbers {
		if value < 0 {
			continue
		}
		sum += value
	}
	fmt.Println("Sum:", sum)

	for _, value := range numbers {
		if value > 4 {
			break
		}
		sum += value
	}
	fmt.Println("Sum:", sum) // Sum: 10
}

// break continue

// Функции и их параметры
/*
Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу.
С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы.

Функция объявляется следующим образом:

func имя_функции (список_параметров) (типы_возвращаемых_значений){
    выполняемые_операторы
}

Функция определяется с помощью ключевого слова func, после которого идет имя функции.
Затем в скобках идет список параметров. После списка параметров определяются типы возвращаемых из функции значений (если функция возвращает значения).
И далее в фигурных скобках идут собственно те операторы, из которых состоит функция.

Название функции вместе с типами ее параметров и типами возвращаемых значений еще называют сигнатурой.
По умолчанию каждая программа на языке Go должна содержать как минимум одну функцию - функцию main

Функция main начинается с ключевого слова func, затем идет название - main. Функция не принимает никаких параметров, поэтому после названия идут пустые скобки.
Функция main не возвращает никакого результата, поэтому после пустых скобок не указывается тип возвращаемого значения.
И тело функции в фигурных скобках фактически состоит из вызова другой функции - fmt.Println(), которая выводит строку на консоль.

Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего параметра,
а предыдущие параметры также будут представлять этот тип:

func main() {
    add(1, 2, 3.4, 5.6, 1.2)
}
func add(x, y int, a, b, c float32){
    var z = x + y
    var d = a + b + c
    fmt.Println("x + y = ", z)
    fmt.Println("a + b + c = ", d)

*/
// Функции и их параметры

// с остальными арифметическими операциями тоже самое
func addition(a int, b int) {
	var c = a + b
	fmt.Println("a + b =", c)
}

// вывод сообщений
func OutputMessage() {
	fmt.Println("Настойчивость")
	fmt.Println("города")
	fmt.Println("берёт.")

	/*
		вывод сообщений в одну строку
		fmt.Println("Настойчивость");fmt.Println("города");fmt.Println("берёт.")
	*/
}

func main() {
	// OutputMessage()
	/*
		Константы - хранят некоторые данные, значение констант нельзя изменить, они устанавливаются один раз.
		Вычисление констант производится во время компиляции
		Необходимо обязательно инициализировать константу начальным значением при ее объявлении
		Константы можно инициализировать только константными значениями, например, литералами типа чисел или строк, или значениями других констант.
		Но инициализировать константу значением переменной мы не можем
	*/
	const pi, e, ep = 2.7182, 1.2348, 2.7182
	fmt.Println(pi, e, ep)
	/*
			Если определяется последовательность констант, то инициализацию значением можно опустить для всех констант, кроме первой.
			В этом случае константа без значения полчит значение предыдущей константы:
			const (
		    a = 1
		    b
		    c
		    d = 3
		    f)
			fmt.Println(a, b, c, d, f)      // 1, 1, 1, 3, 3
	*/

	// переменные
	var (
		// пример неявной типизации
		growth = 190
		name   = "Alex"
		// либо так неявная типизация
		// var name, age = "Tom", 27
		/*
			Надо либо указать тип данных (в этом случае переменная будет иметь значение по умолчанию):
			var name string
			Либо указать начальное значение, на основании которого выводится тип данных:
			var name = "Tom"
			Либо и то, и другое одновременно:
			var name string = "Tom"
		*/
	)

	// краткое определение переменной
	// тип выводится автоматически из присваимого значения
	weight := 95

	fmt.Println(growth)
	fmt.Println(name)
	fmt.Println(weight)

	addition(4, 5)
	addition(7, 3)
	addition(2, 1)

	ConditionalStatements(5, 7)
	EnumerationManyOptions(37)
	//loopExample()
	//IteratingOverArrays()
	interruptionPossibilities()
}

/*
Справка по типам данных

Целочисленные типы данных
int8: представляет целое число от -128 до 127 и занимает в памяти 1 байт (8 бит)
int16: представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)
int32: представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)
int64: представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)
uint8: представляет целое число от 0 до 255 и занимает 1 байт
uint16: представляет целое число от 0 до 65535 и занимает 2 байта
uint32: представляет целое число от 0 до 4294967295 и занимает 4 байта
uint64: представляет целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт
byte: синоним типа uint8, представляет целое число от 0 до 255 и занимает 1 байт
rune: синоним типа int32, представляет целое число от -2147483648 до 2147483647 и занимает 4 байта
int: представляет целое число со знаком, которое в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.
uint: представляет целое беззнаковое число только без знака, которое, аналогично типу int, в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.

Примеры определения целочисленных переменных
var a int8 = -1
var b uint8 = 2
var c byte = 3  // byte - синоним типа uint8
var d int16 = -4
var f uint16 = 5
var g int32 = -6
var h rune = -7     // rune - синоним типа int32
var j uint32 = 8
var k int64 = -9
var l uint64 = 10
var m int = 102
var n uint = 105

Числа с плавающей точкой
Для представления дробных чисел есть два типа:

float32: представляет число с плавающей точкой от 1.4*10-45 до 3.4*1038(для положительных). Занимает в памяти 4 байта (32 бита)

float64: представляет число с плавающей точкой от 4.9*10-324 до 1.8*10308 (для положительных) и занимает 8 байт.

Тип float32 обеспечивает шесть десятичных цифр точности, в то время как точность, обеспечиваемая типом float64, составляет около 15 цифр

Примеры использования типов float32 и float64:

var f float32 = 18
var g float32 = 4.5
var d float64 = 0.23
var pi float64 = 3.14
var e float64 = 2.7
В качестве разделителя между целой и дробной частью применяется точка.

Комплексные числа
Существуют отдельные типы для представления комплексных чисел:
complex64: комплексное число, где вещественная и мнимая части представляют числа float32
complex128: комплексное число, где вещественная и мнимая части представляют числа float64
Пример использования:
var f complex64 = 1+2i
var g complex128 = 4+3i

Тип bool
Логический тип или тип bool может иметь одно из двух значений: true (истина) или false (ложь).

var isAlive bool = true
var isEnabled bool = false

Строки
Строки представлены типом string. В Go строке соответствует строковый литерал - последовательность символов, заключенная в двойные кавычки:

var name string = "Том Сойер"
Кроме обычных символов строка может содержать специальные последовательности (управляющие последовательности), которые начинаются с обратного слеша \. Наиболее распространенные последовательности:
\n: переход на новую строку
\r: возврат каретки
\t: табуляция
\": двойная кавычка внутри строк
\\: обратный слеш

Значение по умолчанию
Если переменной не присвоено значение, то она имеет значение по умолчанию, которое определено для ее типа. Для числовых типов это число 0, для логического типа - false, для строк - ""(пустая строка).
*/
